-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Validate generalized hypertable for smallint
CREATE TABLE test_table_smallint(id SMALLINT, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_smallint', 'id');
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (1,t)
(1 row)

-- default interval
SELECT integer_interval FROM timescaledb_information.dimensions WHERE hypertable_name = 'test_table_smallint';
 integer_interval 
------------------
            10000
(1 row)

-- Add data with default partition (10000)
INSERT INTO test_table_smallint VALUES (1, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_smallint VALUES (9999, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_smallint VALUES (10000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_smallint VALUES (20000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
-- Number of chunks
SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name='test_table_smallint';
 count 
-------
     3
(1 row)

-- Validate generalized hypertable for int
CREATE TABLE test_table_int(id INTEGER, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id');
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (2,t)
(1 row)

-- Default interval
SELECT integer_interval FROM timescaledb_information.dimensions WHERE hypertable_name = 'test_table_int';
 integer_interval 
------------------
           100000
(1 row)

-- Add data
INSERT INTO test_table_int VALUES (1, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_int VALUES (99999, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_int VALUES (100000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_int VALUES (200000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
-- Number of chunks
SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name='test_table_int';
 count 
-------
     3
(1 row)

-- Validate generalized hypertable for int
CREATE TABLE test_table_bigint(id BIGINT, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_bigint', 'id');
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (3,t)
(1 row)

-- Default interval
SELECT integer_interval FROM timescaledb_information.dimensions WHERE hypertable_name = 'test_table_bigint';
 integer_interval 
------------------
          1000000
(1 row)

-- Add data
INSERT INTO test_table_bigint VALUES (1, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_bigint VALUES (999999, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_bigint VALUES (1000000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_bigint VALUES (2000000, 10, '01-01-2023 11:00'::TIMESTAMPTZ);
-- Number of chunks
SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name='test_table_bigint';
 count 
-------
     3
(1 row)

DROP TABLE test_table_smallint;
DROP TABLE test_table_int;
DROP TABLE test_table_bigint;
-- Create hypertable with SERIAL column
CREATE TABLE jobs_serial (job_id SERIAL, device_id INTEGER, start_time TIMESTAMPTZ, end_time TIMESTAMPTZ, PRIMARY KEY (job_id));
SELECT timescaledb_experimental.create_hypertable('jobs_serial', 'job_id', partition_interval => 30);
 create_hypertable 
-------------------
 (4,t)
(1 row)

-- Insert data
INSERT INTO jobs_serial (device_id, start_time, end_time)
SELECT abs(timestamp_hash(t::timestamp)) % 10, t, t + INTERVAL '1 day'
FROM generate_series('2018-03-02 1:00'::TIMESTAMPTZ, '2018-03-08 1:00':: TIMESTAMPTZ,'1 hour')t;
-- Verify chunk pruning
EXPLAIN VERBOSE SELECT * FROM jobs_serial WHERE job_id < 30;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Index Scan using "10_1_jobs_serial_pkey" on _timescaledb_internal._hyper_4_10_chunk  (cost=0.15..20.30 rows=523 width=24)
   Output: _hyper_4_10_chunk.job_id, _hyper_4_10_chunk.device_id, _hyper_4_10_chunk.start_time, _hyper_4_10_chunk.end_time
   Index Cond: (_hyper_4_10_chunk.job_id < 30)
(3 rows)

EXPLAIN VERBOSE SELECT * FROM jobs_serial WHERE job_id >= 30 AND job_id < 90;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Append  (cost=0.15..14.71 rows=16 width=24)
   ->  Index Scan using "11_2_jobs_serial_pkey" on _timescaledb_internal._hyper_4_11_chunk  (cost=0.15..7.31 rows=8 width=24)
         Output: _hyper_4_11_chunk.job_id, _hyper_4_11_chunk.device_id, _hyper_4_11_chunk.start_time, _hyper_4_11_chunk.end_time
         Index Cond: ((_hyper_4_11_chunk.job_id >= 30) AND (_hyper_4_11_chunk.job_id < 90))
   ->  Index Scan using "12_3_jobs_serial_pkey" on _timescaledb_internal._hyper_4_12_chunk  (cost=0.15..7.31 rows=8 width=24)
         Output: _hyper_4_12_chunk.job_id, _hyper_4_12_chunk.device_id, _hyper_4_12_chunk.start_time, _hyper_4_12_chunk.end_time
         Index Cond: ((_hyper_4_12_chunk.job_id >= 30) AND (_hyper_4_12_chunk.job_id < 90))
(7 rows)

EXPLAIN VERBOSE SELECT * FROM jobs_serial WHERE job_id > 90;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Append  (cost=0.15..45.84 rows=1046 width=24)
   ->  Index Scan using "13_4_jobs_serial_pkey" on _timescaledb_internal._hyper_4_13_chunk  (cost=0.15..20.30 rows=523 width=24)
         Output: _hyper_4_13_chunk.job_id, _hyper_4_13_chunk.device_id, _hyper_4_13_chunk.start_time, _hyper_4_13_chunk.end_time
         Index Cond: (_hyper_4_13_chunk.job_id > 90)
   ->  Index Scan using "14_5_jobs_serial_pkey" on _timescaledb_internal._hyper_4_14_chunk  (cost=0.15..20.30 rows=523 width=24)
         Output: _hyper_4_14_chunk.job_id, _hyper_4_14_chunk.device_id, _hyper_4_14_chunk.start_time, _hyper_4_14_chunk.end_time
         Index Cond: (_hyper_4_14_chunk.job_id > 90)
(7 rows)

-- Update rows
UPDATE jobs_serial SET end_time = end_time + INTERVAL '1 hour' where job_id = 1;
UPDATE jobs_serial SET end_time = end_time + INTERVAL '1 hour' where job_id = 30;
UPDATE jobs_serial SET end_time = end_time + INTERVAL '1 hour' where job_id = 90;
SELECT start_time, end_time FROM jobs_serial WHERE job_id = 1;
          start_time          |           end_time           
------------------------------+------------------------------
 Fri Mar 02 01:00:00 2018 PST | Sat Mar 03 02:00:00 2018 PST
(1 row)

SELECT start_time, end_time FROM jobs_serial WHERE job_id = 30;
          start_time          |           end_time           
------------------------------+------------------------------
 Sat Mar 03 06:00:00 2018 PST | Sun Mar 04 07:00:00 2018 PST
(1 row)

SELECT start_time, end_time FROM jobs_serial WHERE job_id = 90;
          start_time          |           end_time           
------------------------------+------------------------------
 Mon Mar 05 18:00:00 2018 PST | Tue Mar 06 19:00:00 2018 PST
(1 row)

-- Delete rows
DELETE FROM jobs_serial WHERE job_id < 10;
SELECT count(*) FROM jobs_serial WHERE job_id < 30;
 count 
-------
    20
(1 row)

DROP TABLE jobs_serial;
-- Create and validate hypertable with BIGSERIAL column
CREATE TABLE jobs_big_serial (job_id BIGSERIAL, device_id INTEGER, start_time TIMESTAMPTZ, end_time TIMESTAMPTZ, PRIMARY KEY (job_id));
SELECT timescaledb_experimental.create_hypertable('jobs_big_serial', 'job_id', partition_interval => 100);
 create_hypertable 
-------------------
 (5,t)
(1 row)

-- Insert data
INSERT INTO jobs_big_serial (device_id, start_time, end_time)
SELECT abs(timestamp_hash(t::timestamp)) % 10, t, t + INTERVAL '1 day'
FROM generate_series('2018-03-02 1:00'::TIMESTAMPTZ, '2018-03-08 1:00'::TIMESTAMPTZ,'30 mins')t;
-- Verify #chunks
SELECT count(*) FROM timescaledb_information.chunks;
 count 
-------
     3
(1 row)

-- Get current sequence and verify updating sequence
SELECT currval(pg_get_serial_sequence('jobs_big_serial', 'job_id'));
 currval 
---------
     289
(1 row)

-- Update sequence value to 500
SELECT setval(pg_get_serial_sequence('jobs_big_serial', 'job_id'), 500, false);
 setval 
--------
    500
(1 row)

-- Insert few rows and verify that the next sequence starts from 500
INSERT INTO jobs_big_serial (device_id, start_time, end_time)
SELECT abs(timestamp_hash(t::timestamp)) % 10, t, t + INTERVAL '1 day'
FROM generate_series('2018-03-09 1:00'::TIMESTAMPTZ, '2018-03-10 1:00'::TIMESTAMPTZ,'30 mins')t;
-- No data should exist for job_id >= 290 to job_id < 500
SELECT count(*) FROM jobs_big_serial WHERE job_id >= 290 AND job_id < 500;
 count 
-------
     0
(1 row)

-- The new rows should be added with job_id > 500
SELECT count(*) from jobs_big_serial WHERE job_id > 500;
 count 
-------
    48
(1 row)

-- Verify show_chunks API
SELECT show_chunks('jobs_big_serial', older_than => 100);
               show_chunks               
-----------------------------------------
 _timescaledb_internal._hyper_5_15_chunk
(1 row)

SELECT show_chunks('jobs_big_serial', newer_than => 200, older_than => 300);
               show_chunks               
-----------------------------------------
 _timescaledb_internal._hyper_5_17_chunk
(1 row)

SELECT show_chunks('jobs_big_serial', newer_than => 500);
               show_chunks               
-----------------------------------------
 _timescaledb_internal._hyper_5_18_chunk
(1 row)

-- Verify drop_chunks API
SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name =
'jobs_big_serial';
 count 
-------
     4
(1 row)

SELECT drop_chunks('jobs_big_serial', newer_than => 500);
               drop_chunks               
-----------------------------------------
 _timescaledb_internal._hyper_5_18_chunk
(1 row)

SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name = 'jobs_big_serial';
 count 
-------
     3
(1 row)

SELECT drop_chunks('jobs_big_serial', newer_than => 200, older_than => 300);
               drop_chunks               
-----------------------------------------
 _timescaledb_internal._hyper_5_17_chunk
(1 row)

SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name = 'jobs_big_serial';
 count 
-------
     2
(1 row)

DROP TABLE jobs_big_serial;
-- Verify partition function
CREATE OR REPLACE FUNCTION part_func(id TEXT)
	RETURNS INTEGER LANGUAGE PLPGSQL IMMUTABLE AS
$BODY$
DECLARE
	retval INTEGER;
BEGIN
	retval := CAST(id AS INTEGER);
	RETURN retval;
END
$BODY$;
CREATE TABLE test_table_int(id TEXT, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_func => 'part_func', partition_interval => 10);
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (6,t)
(1 row)

INSERT INTO test_table_int VALUES('1', 1, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_int VALUES('10', 10, '01-01-2023 11:00'::TIMESTAMPTZ);
INSERT INTO test_table_int VALUES('29', 100, '01-01-2023 11:00'::TIMESTAMPTZ);
SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name = 'test_table_int';
 count 
-------
     3
(1 row)

DROP TABLE test_table_int;
DROP FUNCTION part_func;
-- Migrate data
CREATE TABLE test_table_int(id INTEGER, device INTEGER, time TIMESTAMPTZ);
INSERT INTO test_table_int SELECT t, t%10, '01-01-2023 11:00'::TIMESTAMPTZ FROM generate_series(1, 50, 1) t;
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_interval => 10, migrate_data => true);
NOTICE:  adding not-null constraint to column "id"
NOTICE:  migrating data to chunks
 create_hypertable 
-------------------
 (7,t)
(1 row)

SELECT count(*) FROM timescaledb_information.chunks WHERE hypertable_name = 'test_table_int';
 count 
-------
     6
(1 row)

DROP TABLE test_table_int;
-- Create default indexes
CREATE TABLE test_table_int(id INTEGER, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_interval => 10, create_default_indexes => false);
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (8,t)
(1 row)

SELECT indexname FROM pg_indexes WHERE tablename = 'test_table_int';
 indexname 
-----------
(0 rows)

DROP TABLE test_table_int;
-- if_not_exists
CREATE TABLE test_table_int(id INTEGER, device INTEGER, time TIMESTAMPTZ);
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_interval => 10);
NOTICE:  adding not-null constraint to column "id"
 create_hypertable 
-------------------
 (9,t)
(1 row)

-- No error when if_not_exists => true
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_interval => 10, if_not_exists => true);
NOTICE:  table "test_table_int" is already a hypertable, skipping
 create_hypertable 
-------------------
 (9,f)
(1 row)

SELECT * FROM _timescaledb_internal.get_create_command('test_table_int');
                                                 get_create_command                                                 
--------------------------------------------------------------------------------------------------------------------
 SELECT create_hypertable('public.test_table_int', 'id', chunk_time_interval => 10, create_default_indexes=>FALSE);
(1 row)

-- Should throw an error when if_not_exists is not set
/set ON_ERROR_STOP 0
SELECT timescaledb_experimental.create_hypertable('test_table_int', 'id', partition_interval => 10);
ERROR:  syntax error at or near "/" at character 1
